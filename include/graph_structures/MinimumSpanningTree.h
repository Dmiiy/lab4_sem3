#ifndef LAB4_SEM3_MINIMUMSPANNINGTREE_H
#define LAB4_SEM3_MINIMUMSPANNINGTREE_H

#include "UndirectedGraph.h"
#include <functional>
#include "QuickSorter.h"
#include "../sequence/ArraySequence.h"
#include <tuple>

/**
 * @brief Класс для поиска минимального остова графа.
 *
 * Класс `MinimumSpanningTree` предоставляет метод для нахождения минимального остова
 * в неориентированном графе, используя алгоритм Крускала. Он реализует структуру
 * данных "система непересекающихся множеств" для эффективного объединения компонент.
 *
 * @tparam T Тип веса рёбер графа.
 */
template <typename T>
class MinimumSpanningTree {
public:
    /**
     * @brief Находит минимальный остов графа с использованием алгоритма Крускала.
     *
     * Метод `kruskal` выполняет поиск минимального остова неориентированного графа
     * с помощью алгоритма Крускала. Он сортирует все рёбра по возрастанию веса
     * и добавляет их последовательно к остову, избегая циклов.
     *
     * @param graph Неориентированный граф, для которого требуется найти минимальный остов.
     * @return ArraySequence<std::tuple<int, int, T>> Список рёбер минимального остова.
     *                                             Каждое ребро представлено кортежем (вершина1, вершина2, вес).
     */
    static ArraySequence<std::tuple<int, int, T>> kruskal(const UndirectedGraph<T>& graph) {
        int vertices = graph.getVertexCount(); /**< Общее количество вершин в графе. */
        ArraySequence<int> parent;             /**< Массив для хранения родительских вершин в системе непересекающихся множеств. */

        // Инициализируем каждую вершину как её собственного родителя
        for (int i = 0; i < vertices; ++i) {
            parent.append(i); /**< Каждая вершина является корнем собственного множества. */
        }

        /**
         * @brief Функция для нахождения корня множества сжатия пути.
         *
         * Метод `find` находит корень множества, к которому принадлежит вершина `v`,
         * и одновременно выполняет сжатие пути для оптимизации будущих операций.
         *
         * @param v Вершина, для которой нужно найти корень.
         * @return int Индекс корня множества.
         */
        std::function<int(int)> find = [&](int v) -> int {
            if (parent[v] != v) {
                parent[v] = find(parent[v]);  /**< Рекурсивно ищем корень и выполняем сжатие пути. */
            }
            return parent[v]; /**< Возвращаем корень множества. */
        };

        /**
         * @brief Функция для объединения двух множеств.
         *
         * Метод `unite` объединяет два множества, в которые принадлежат вершины `u` и `v`.
         *
         * @param u Первая вершина.
         * @param v Вторая вершина.
         */
        std::function<void(int, int)> unite = [&](int u, int v) {
            int rootU = find(u); /**< Находим корень множества первой вершины. */
            int rootV = find(v); /**< Находим корень множества второй вершины. */
            if (rootU != rootV) {
                parent[rootU] = rootV;  /**< Объединяем два множества, присваивая корню одного множество другого. */
            }
        };

        ArraySequence<std::tuple<int, int, T>> mst; /**< Список рёбер минимального остова. */
        ArraySequence<std::tuple<int, int, T>> edges = graph.getEdges(); /**< Получаем все рёбра графа. */

        /**
         * @brief Сортируем рёбра по возрастанию веса с помощью быстрого сортировщика.
         *
         * Используется класс `QuickSorter` для эффективной сортировки рёбер.
         */
        QuickSorter<std::tuple<int, int, T>> sorter([](const std::tuple<int, int, T>& a, const std::tuple<int, int, T>& b) {
            return std::get<2>(a) < std::get<2>(b);  /**< Сортировка по третьему элементу кортежа - весу ребра. */
        });

        sorter.sort(&edges); /**< Сортируем рёбра по возрастанию веса. */

        /**
         * @brief Проходим по отсортированным рёбрам и добавляем их в остов.
         *
         * Добавляем ребро в остов, если оно соединяет две разные компоненты связности,
         * тем самым избегая создания циклов.
         */
        for (int i = 0; i < edges.getLength(); ++i) {
            const auto& edge = edges[i]; /**< Текущее ребро. */
            int u = std::get<0>(edge);   /**< Первая вершина ребра. */
            int v = std::get<1>(edge);   /**< Вторая вершина ребра. */
            T weight = std::get<2>(edge); /**< Вес ребра. */

            if (find(u) != find(v)) { /**< Проверяем, принадлежат ли вершины к разным множествам. */
                mst.append(edge);      /**< Добавляем ребро в минимальный остов. */
                unite(u, v);           /**< Объединяем множества вершин. */

                // Если остов содержит (vertices - 1) рёбер, алгоритм завершается
                if (mst.getLength() == vertices - 1) {
                    break; /**< Достигнут минимальный набор рёбер для остова. */
                }
            }
        }

        return mst;  /**< Возвращаем список рёбер минимального остова. */
    }
};

#endif // LAB4_SEM3_MINIMUMSPANNINGTREE_H